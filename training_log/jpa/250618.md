# 🗓️ 2025.06.18 (수) – 교육 일지

## 📚 오늘 배운 내용
### JPA
#### Persistance Context lifecycle
- Persistence Context란?
  - 엔티티를 영구 저장하는 환경
  - 엔티티 매니저에 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
  - 영속성 엔티티를 key-value 방식으로 저장하는 저장소 역할을 한다.
  - 영속성 컨텍스트는 엔티티 매니저를 생성할 때마다 하나씩 만들어진다.
  - 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고 영속성 컨텍스트를 관리할 수 있다.
- Entity LifeCycle
  - 비영속 상태 (New/Transient)
    - 엔티티 객체가 생성되고, 아직 영속성 컨텍스트에 저장되지 않은 상태 
  - 영속 상태 (Managed)
    - 엔티티 객체가 영속성 컨텍스트에 저장된 상태. 
    - 이 상태에서 엔티티를 수정하면 자동으로 데이터 베이스에 반영
  - 준영속 상태 (Detached)
    - 엔티티 객체가 영속성 컨텍스트와 분리된 상태. 
    - 이 상태에서는 엔티티를 수정해도 데이터에는 반영되지 않는다.
    - 분리된 엔티티를 다시 관리 상태로 만들어주기 위해서는 `EntityManager` 객체의 `merge()` 메소드를 사용한다.
  - 삭제 상태 (Removed)
    - 엔티티 객체가 영속성 컨텍스트에서 제거된 상태. 
    - 이 상태에서는 엔티티를 수정해도 데이터베이스에는 반영되지 않는다.
- Entity LifeCycle을 관리하는 메소드
  - `entityManager.detach(foundMenu)` : 특정 엔티티(여기서는 foundMenu)만 준영속 상태(영속성 컨텍스트가 관리하던 객체를 관리하지 않음)로 만든다.
  - `entityManager.flush()` : 영속성 컨텍스트의 상태를 DB로 내보낸다. commit하지 않은 상태이므로 `rollback()`이 가능하다.
    - 여기서 detach 후 flush를 하게 된다면 detach한 값은 P.C에 없는채로 DB로 내보내지게 된다.
  - `entityManager.merge(foundMenu)`
    - 파라미터로 넘어온 준영속 엔티티 객체(여기서는 foundMenu)의 식별자 값으로 1차 캐시에서 엔티티 객체를 조회한다. (.merge() 이전에 .detach()를 해줘서 준영속 상태로 만든 상황)
    - 없으면 DB에서 조회하여 1차 캐시에 저장한다.
    - 즉, 조회한 영속 엔티티 객체에 준영속 상태의 엔티티 객체의 값을 병합 한 뒤 영속 엔티티 객체를 반환한다.
    - 조회할 수 없는 데이터라면 새로 생성해서 병합한다.


#### mapping in spring
## 💻 실습 예시
### JPA
- [JPA를 써야하는 이유](../../JPA/chapter00-intro)
- [EntityManager lifecycle & JPA CRUD](../../JPA/chapter01-persistence-context)

## ✍️ 오늘의 회고
- 오늘은 JPA를 학습하면서 기존에 사용하던 JDBC나 MyBatis와의 차이를 많이 느꼈다.
  예전엔 쿼리문도 직접 작성하고, 매핑도 일일이 처리해줘야 해서 은근히 번거로운 작업이 많았는데,
  JPA는 객체 중심으로 데이터를 다루다 보니 확실히 개발 생산성이 높아진 느낌이다.
- 특히 쿼리를 따로 작성하지 않아도 persist, find, merge, remove 같은 메서드만으로 대부분의 작업이 가능하다는 점이 굉장히 편리했다.
  단순 CRUD라면 JPA로 충분하고, 복잡한 조건이나 성능 최적화가 필요한 쿼리의 경우에는 직접 쿼리를 작성해야 할 수도 있겠다는 생각이 들었다.
- 상황에 따라 JPA와 MyBatis를 적절히 혼용하는 방식도 고려해볼 만한 것 같다.
  예를 들어, 복잡한 조인이나 성능이 중요한 상황에서는 MyBatis를 쓰고,
  그 외 대부분의 비즈니스 로직에서는 JPA를 사용하는 방식으로....