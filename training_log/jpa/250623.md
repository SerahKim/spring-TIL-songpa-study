# 🗓️ 2025.06.23 (월) – 교육 일지

## 📚 오늘 배운 내용
### JPA
#### JPQL
- Group Function
  - JPQL의 그룹함수는 COUNT, MAX, MIN, SUM, AVG로 SQL의 그룹함수와 차이가 없다.
  - 주의사항
    - 1. 그룹함수의 반환 타입은 결과 값이 정수면 Long, 실수면 Double로 반환된다.
    - 2. 값이 없는 상태에서 count를 제외한 그룹 함수는 null이되고 count만 0이 된다. 따라서 반환값을 담기 위해 선언하는 변수 타입을 기본자료형으로 하게 되면, 조회 결과를 언박싱할 떄 NPE가 발생한다.
    - 3. 그룹 함수의 반환 자료형은 Long 또는 Double 형이기 때문에 Having 절에서 그룹 함수 결과값과 비교하기 위한 파라미터 타입은 Long or Double로 해야한다.
  - 예시
    - COUNT가 아닌 그룹함수는 Wrapper Class로 반환 받아야 한다.
      ```
      public Long otherWithNoReuslt(int categoryCode) {
        String jpql = "SELECT SUM(m.menuPrice) FROM Section05Menu m WHERE m.categoryCode = :categoryCode";

        Long sumOfMenu = entityManager.createQuery(jpql, Long.class)
                .setParameter("categoryCode", categoryCode)
                .getSingleResult();

        return sumOfMenu;
      }
      ``` 
- Join
  - 일반적인 SQL 조인을 의미한다. (Inner Join, Outer Join 등등)
  - Inner Join
    ```
    /* 문제점 */
    
    public List<Menu> selectByInnerJoin() {
        String jpql = "SELECT m FROM Section06Menu m JOIN m.category c";

        List<Menu> menuList = entityManager.createQuery(jpql, Menu.class).getResultList();

        return menuList;
    }
    ```
    - 이미 엔티티에서 Join 관계를 표현해주고 있기 때문에 ON을 작성해줄 필요는 없다.
    - 이 코드에서는 Menu 엔티티는 한번의 쿼리로 다 불러오지만 그 안에 있는 category 필드는 지연로딩 됨.
    - 따라서 각 메뉴마다 개별적으로 SELECT 문을 실행하게 되고 모든 카테고리를 다 불러올 때까지 반복됨.
    - 총 N+1번의 쿼리가 실행되게 되는 N+1문제가 발생하게 된다.
    ```
    /* 해결 방법 */
    
    public List<Menu> selectByFetchJoin() {
        String jpql = "SELECT m FROM Section06Menu m JOIN FETCH m.category c";

        List<Menu> menuList = entityManager.createQuery(jpql, Menu.class).getResultList();

        return menuList;
    }
    ```
    - JOIN FETCH를 사용하면 JPA가 Menu와 Category를 한 번의 쿼리로 모두 가져옴 (즉시 로딩)
    - 결과적으로 N+1 문제가 발생하지 않는다.
  - Outer Join
    ```
    public List<Object[]> selectByOuterJoin() {
        String jpql = "SELECT m.menuName, c.categoryName FROM Section06Menu m " +
                "RIGHT JOIN m.category c " +
                "ORDER BY m.category.categoryCode";

        List<Object[]> menuList = entityManager.createQuery(jpql).getResultList();

        return menuList;
    }
    ```
    - JPQL을 통해 Right Join, Left Join 등 Outer Join도 가능하다
  - Collection Join
    ```
    public List<Object[]> selectByCollectionJoin() {
        String jpql = "SELECT m.menuName, c.categoryName FROM Section06Category c " +
                "RIGHT JOIN c.menuList m " +
                "ORDER BY m.category.categoryCode";

        List<Object[]> categoryList = entityManager.createQuery(jpql).getResultList();

        return categoryList;
    }
    ```
    - JPA에서 엔티티 안에 포함된 컬렉션(List, Set 등)을 조인하는 것

#### native query
- native query
  - 데이터베이스에 직접 사용하는 원시 SQL 문을 JPA에서 실행하는 방식
  - 엔티티명을 적는 JPQL과는 SQL 문법이 다르다.
- named query

## 💻 실습 예시
### JPA
- [bidirection](../../JPA/chapter03-association-mapping/src/main/java/com/associationmapping/section03)
- [jpql](../../JPA/chapter04-jpql)

## ✍️ 오늘의 회고
- 오늘은 JPA의 연관관계 매핑과 JPQL에 대해 배웠다.
  연관관계 매핑에서는 양방향 연관관계의 개념과 주의할 점을 배웠는데, 특히 연관관계의 주인을 명확히 정하는 게 중요하다는 걸 다시 느꼈다. DB 입장에서 외래키를 가진 쪽이 주인이라는 개념이 처음엔 좀 낯설었지만, 예제를 보면서 이해가 쉬워졌다. 양방향일 때는 양쪽 모두 값을 세팅해야 객체 상태가 일관되게 유지된다는 것도 실무에서 꼭 기억해야 할 부분 같다.
- JPQL은 기존 SQL과 유사하면서도 객체 중심으로 쿼리할 수 있다는 점이 흥미로웠다. 특히 TypedQuery와 Query의 차이, 파라미터 바인딩 방식, 그리고 다양한 프로젝션 방식(엔티티, 임베디드, 스칼라, DTO)을 비교하면서 어떤 방식이 언제 적합한지 알 수 있었다.
- 그중에서도 DTO 프로젝션을 통해 타입 안정성과 가독성을 확보할 수 있다는 게 가장 인상 깊었다. 다만, 엔티티가 아니기 때문에 영속성 컨텍스트에서 관리되지 않는다는 점은 주의해야겠다고 느꼈다.